## Комбинаторные объекты

Это дополнительное задание для студентов первого курса &mdash;
групп 17.Б01-мм и 17.Б02-мм.

При изучении математики мы часто сталкиваемся с комбинаторными объектами.
Например, это могут быть перестановки, подмножества заданного множества,
слова Дика, разбиения на слагаемые, разбиения множества на подмножества.
При работе с такими объектами возникают типичные задачи:
записать объект, посчитать количество объектов заданного размера,
показать все объекты в каком-то удобном порядке, перебрать их в этом порядке,
или даже научиться быстро по номеру в этом порядке узнавать объект и наоборот.

В этом задании мы систематизируем знания о различных комбинаторных объектах
и решения типичных задач для них.
В процессе решения мы будем использовать язык C++
(в частности, классы и наследование),
а также систему контроля версий Git и онлайн-платформу GitHub.

## Задание

Каждый студент может выполнить следующие части задания:

1. Выбрать интересный комбинаторный объект и способ его записи,
для которого задание ещё не выполнено.

    * Формальные критерии: объект должен иметь размер &mdash;
целое число n &mdash; и записываться как последовательность из n целых чисел.
Если интересный вам объект обычно записывается иначе,
попробуйте найти другой подходящий способ записи.
Например, правильные скобочные последовательности в чистом виде не подходят,
так как состоят из скобок, но их можно записывать как слова Дика,
состоящие из цифр 0 и 1.
Разбиения числа n на слагаемые обычно записываются
как последовательности слагаемых и имеют разную длину,
но разбиение можно записать и в виде n чисел &mdash; например,
указав, какому по счёту слагаемому принадлежит каждая из n единичек суммы.

    * Примерный критерий интересности объекта:
наличие последовательности &laquo;количество таких объектов размера n&raquo;
в On-Line Encyclopedia of Integer Sequences, http://oeis.org/.
Например, для перестановок это факториалы, http://oeis.org/A000142,
для скобочных последовательностей это числа Каталана, http://oeis.org/A000108,
а для подмножеств заданного множества
это степени двойки, http://oeis.org/A000079.
Если вы не уверены, что ваш объект интересный &mdash;
обсудите это с преподавателем, прежде чем выполнять задание.

2. Завести аккаунт на сайте https://github.com и скопировать (fork) себе
репозиторий задания:
https://github.com/spbsu-student-projects/combinatorial-objects.
Там есть общий класс для всех подходящих комбинаторных объектов,
который называется `CombinatorialObject`: в этот момент, вероятно,
стоит изучить его
[описание](https://github.com/spbsu-student-projects/combinatorial-objects/blob/master/combinatorial_object/combinatorial_object.h) и
[реализацию](https://github.com/spbsu-student-projects/combinatorial-objects/blob/master/combinatorial_object/combinatorial_object.cpp).
Есть также [пример](https://github.com/spbsu-student-projects/combinatorial-objects/tree/master/fibonacci_string)
выполненного задания для строк Фибоначчи,
а также, возможно, другие выполненные задания.

3. В своей копии завести каталог для выбранного комбинаторного объекта,
написав его название маленькими английскими буквами и знаками подчёркивания.
Далее мы для примера будем рассматривать выдуманный объект
&laquo;макаронный монстр&raquo;, так что каталог будет называться
`spaghetti_monster`.
Там следует завести несколько файлов:

    * Файл `spaghetti_monster.h`, в котором будет описан класс
`SpaghettiMonster` &mdash; наследник класса `CombinatorialObject`.

    * Файл `spaghetti_monster.cpp`, который будет содержать реализацию
класса `SpaghettiMonster`.

    * Файл `readme.markdown`, где будет написано несколько предложений
о выбранном комбинаторном объекте и реализованных функциях.

    * Служебный файл `runner.cpp` для запуска вашего решения,
в котором по сравнению с примером поменяются
только автор, строка `#include` и название класса.

    * Служебный файл `Makefile` для сборки вашего решения,
в котором по сравнению с примером поменяется
только имя объекта в первой строке.

    * Возможно, вам удобно будет завести дополнительные служебные файлы,
например, файлы проекта для Visual Studio, CodeBlocks или другой
среды программирования, которой вы пользуетесь.

4. Реализовать в своём классе следующие шесть функций:

    * `total (n)`: посчитать количество объектов размера `n`.

    * `generate_all (n)`: показать все объекты размера `n`
в лексикографическом порядке.

    * `number_by_object (v)`: среди всех объектов такого же размера, как `v`,
найти номер объекта `v` в лексикографическом порядке, считая с нуля.

    * `object_by_number (n, k)`: среди всех объектов размера `n`
найти `k`-й объект в лексикографическом порядке, считая с нуля.

    * `prev (v)`: сделать из объекта `v` предыдущий объект
такого же размера в лексикографическом порядке, если он существует,
и при этом вернуть результат &mdash; существует ли он.

    * `next (v)`: сделать из объекта `v` следующий объект
такого же размера в лексикографическом порядке, если он существует,
и при этом вернуть результат &mdash; существует ли он.

6. Предложить выполненное задание на проверку.
Для этого нужно создать Pull Request к исходному репозиторию,
а после этого реагировать на комментарии к нему &mdash; вполне возможно,
потребуется что-то доделать или переделать.

7. Исправить, улучшить или дополнить часть другого решения.
